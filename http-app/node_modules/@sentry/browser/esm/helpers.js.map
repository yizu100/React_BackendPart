{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../src/helpers.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,gBAAgB,EAAE,aAAa,EAAE,SAAS,EAAE,MAAM,cAAc,CAAC;AAE1E,OAAO,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,gBAAgB,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAE1G,IAAM,gBAAgB,GAAW,IAAI,CAAC;AACtC,IAAI,eAAmC,CAAC;AACxC,IAAI,iBAAoC,CAAC;AACzC,IAAI,aAAa,GAAW,CAAC,CAAC;AAE9B;;GAEG;AACH,MAAM,UAAU,mBAAmB;IACjC,OAAO,aAAa,GAAG,CAAC,CAAC;AAC3B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,iBAAiB;IAC/B,2CAA2C;IAC3C,aAAa,IAAI,CAAC,CAAC;IACnB,UAAU,CAAC;QACT,aAAa,IAAI,CAAC,CAAC;IACrB,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,IAAI,CAClB,EAAmB,EACnB,OAGM,EACN,MAAwB;IAJxB,wBAAA,EAAA,YAGM;IAGN,kDAAkD;IAClD,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE;QAC5B,OAAO,EAAE,CAAC;KACX;IAED,IAAI;QACF,+BAA+B;QAC/B,IAAI,EAAE,CAAC,UAAU,EAAE;YACjB,OAAO,EAAE,CAAC;SACX;QAED,6EAA6E;QAC7E,IAAI,EAAE,CAAC,kBAAkB,EAAE;YACzB,OAAO,EAAE,CAAC,kBAAkB,CAAC;SAC9B;KACF;IAAC,OAAO,CAAC,EAAE;QACV,4DAA4D;QAC5D,gEAAgE;QAChE,6EAA6E;QAC7E,OAAO,EAAE,CAAC;KACX;IAED,IAAM,aAAa,GAAoB;QACrC,kDAAkD;QAClD,IAAI,MAAM,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;YAC1C,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAC/B;QAED,IAAM,IAAI,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAEnD,+BAA+B;QAC/B,IAAI;YACF,IAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,UAAC,GAAQ,IAAK,OAAA,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,EAAlB,CAAkB,CAAC,CAAC;YAEpE,IAAI,EAAE,CAAC,WAAW,EAAE;gBAClB,uCAAuC;gBACvC,0EAA0E;gBAC1E,6FAA6F;gBAC7F,iFAAiF;gBACjF,OAAO,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;aACrD;YAED,uCAAuC;YACvC,0EAA0E;YAC1E,6FAA6F;YAC7F,iFAAiF;YACjF,OAAO,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;YACxC,8BAA8B;SAC/B;QAAC,OAAO,EAAE,EAAE;YACX,iBAAiB,EAAE,CAAC;YAEpB,SAAS,CAAC,UAAC,KAAY;gBACrB,KAAK,CAAC,iBAAiB,CAAC,UAAC,KAAkB;oBACzC,IAAM,cAAc,wBAAQ,KAAK,CAAE,CAAC;oBAEpC,IAAI,OAAO,CAAC,SAAS,EAAE;wBACrB,qBAAqB,CAAC,cAAc,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;wBAC5D,qBAAqB,CAAC,cAAc,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;qBAC1D;oBAED,cAAc,CAAC,KAAK,wBACf,cAAc,CAAC,KAAK,IACvB,SAAS,EAAE,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,GAC9B,CAAC;oBAEF,OAAO,cAAc,CAAC;gBACxB,CAAC,CAAC,CAAC;gBAEH,gBAAgB,CAAC,EAAE,CAAC,CAAC;YACvB,CAAC,CAAC,CAAC;YAEH,MAAM,EAAE,CAAC;SACV;IACH,CAAC,CAAC;IAEF,mCAAmC;IACnC,kEAAkE;IAClE,IAAI;QACF,KAAK,IAAM,QAAQ,IAAI,EAAE,EAAE;YACzB,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,EAAE,QAAQ,CAAC,EAAE;gBACtD,aAAa,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,CAAC;aACxC;SACF;KACF;IAAC,OAAO,GAAG,EAAE,GAAE,CAAC,+BAA+B;IAEhD,EAAE,CAAC,SAAS,GAAG,EAAE,CAAC,SAAS,IAAI,EAAE,CAAC;IAClC,aAAa,CAAC,SAAS,GAAG,EAAE,CAAC,SAAS,CAAC;IAEvC,MAAM,CAAC,cAAc,CAAC,EAAE,EAAE,oBAAoB,EAAE;QAC9C,UAAU,EAAE,KAAK;QACjB,KAAK,EAAE,aAAa;KACrB,CAAC,CAAC;IAEH,4DAA4D;IAC5D,qEAAqE;IACrE,MAAM,CAAC,gBAAgB,CAAC,aAAa,EAAE;QACrC,UAAU,EAAE;YACV,UAAU,EAAE,KAAK;YACjB,KAAK,EAAE,IAAI;SACZ;QACD,mBAAmB,EAAE;YACnB,UAAU,EAAE,KAAK;YACjB,KAAK,EAAE,EAAE;SACV;KACF,CAAC,CAAC;IAEH,+DAA+D;IAC/D,IAAI;QACF,IAAM,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,aAAa,EAAE,MAAM,CAAuB,CAAC;QAChG,IAAI,UAAU,CAAC,YAAY,EAAE;YAC3B,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,MAAM,EAAE;gBAC3C,GAAG,EAAH;oBACE,OAAO,EAAE,CAAC,IAAI,CAAC;gBACjB,CAAC;aACF,CAAC,CAAC;SACJ;KACF;IAAC,OAAO,GAAG,EAAE;QACZ,YAAY;KACb;IAED,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,IAAI,aAAa,GAAW,CAAC,CAAC;AAE9B;;;;;GAKG;AACH,MAAM,UAAU,sBAAsB,CAAC,SAAiB,EAAE,QAAyB;IAAzB,yBAAA,EAAA,gBAAyB;IACjF,OAAO,UAAC,KAAY;QAClB,0DAA0D;QAC1D,8DAA8D;QAC9D,oCAAoC;QACpC,eAAe,GAAG,SAAS,CAAC;QAC5B,uEAAuE;QACvE,yEAAyE;QACzE,8BAA8B;QAC9B,IAAI,CAAC,KAAK,IAAI,iBAAiB,KAAK,KAAK,EAAE;YACzC,OAAO;SACR;QAED,iBAAiB,GAAG,KAAK,CAAC;QAE1B,IAAM,iBAAiB,GAAG;YACxB,IAAI,MAAM,CAAC;YAEX,sEAAsE;YACtE,IAAI;gBACF,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,gBAAgB,CAAC,KAAK,CAAC,MAAc,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAE,KAAyB,CAAC,CAAC;aAC/G;YAAC,OAAO,CAAC,EAAE;gBACV,MAAM,GAAG,WAAW,CAAC;aACtB;YAED,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;gBACvB,OAAO;aACR;YAED,aAAa,EAAE,CAAC,aAAa,CAC3B;gBACE,QAAQ,EAAE,QAAM,SAAW;gBAC3B,OAAO,EAAE,MAAM;aAChB,EACD;gBACE,KAAK,OAAA;gBACL,IAAI,EAAE,SAAS;aAChB,CACF,CAAC;QACJ,CAAC,CAAC;QAEF,IAAI,aAAa,EAAE;YACjB,YAAY,CAAC,aAAa,CAAC,CAAC;SAC7B;QAED,IAAI,QAAQ,EAAE;YACZ,aAAa,GAAG,UAAU,CAAC,iBAAiB,CAAC,CAAC;SAC/C;aAAM;YACL,iBAAiB,EAAE,CAAC;SACrB;IACH,CAAC,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,oBAAoB;IAClC,wDAAwD;IACxD,4DAA4D;IAC5D,gEAAgE;IAChE,OAAO,UAAC,KAAY;QAClB,IAAI,MAAM,CAAC;QAEX,IAAI;YACF,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;SACvB;QAAC,OAAO,CAAC,EAAE;YACV,oFAAoF;YACpF,wDAAwD;YACxD,OAAO;SACR;QAED,IAAM,OAAO,GAAG,MAAM,IAAK,MAAsB,CAAC,OAAO,CAAC;QAE1D,yDAAyD;QACzD,8DAA8D;QAC9D,kCAAkC;QAClC,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,KAAK,OAAO,IAAI,OAAO,KAAK,UAAU,IAAI,CAAE,MAAsB,CAAC,iBAAiB,CAAC,EAAE;YAC7G,OAAO;SACR;QAED,2DAA2D;QAC3D,mCAAmC;QACnC,IAAI,CAAC,eAAe,EAAE;YACpB,sBAAsB,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC;SACxC;QACD,YAAY,CAAC,eAAe,CAAC,CAAC;QAE9B,eAAe,GAAI,UAAU,CAAC;YAC5B,eAAe,GAAG,SAAS,CAAC;QAC9B,CAAC,EAAE,gBAAgB,CAAmB,CAAC;IACzC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { captureException, getCurrentHub, withScope } from '@sentry/core';\nimport { Event as SentryEvent, Mechanism, Scope, WrappedFunction } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, htmlTreeAsString, normalize } from '@sentry/utils';\n\nconst debounceDuration: number = 1000;\nlet keypressTimeout: number | undefined;\nlet lastCapturedEvent: Event | undefined;\nlet ignoreOnError: number = 0;\n\n/**\n * @hidden\n */\nexport function shouldIgnoreOnError(): boolean {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nexport function ignoreNextOnError(): void {\n  // onerror should trigger before setTimeout\n  ignoreOnError += 1;\n  setTimeout(() => {\n    ignoreOnError -= 1;\n  });\n}\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap.\n * @returns The wrapped function.\n * @hidden\n */\nexport function wrap(\n  fn: WrappedFunction,\n  options: {\n    mechanism?: Mechanism;\n    capture?: boolean;\n  } = {},\n  before?: WrappedFunction,\n): any {\n  // tslint:disable-next-line:strict-type-predicates\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  try {\n    // We don't wanna wrap it twice\n    if (fn.__sentry__) {\n      return fn;\n    }\n\n    // If this has already been wrapped in the past, return that wrapped function\n    if (fn.__sentry_wrapped__) {\n      return fn.__sentry_wrapped__;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  const sentryWrapped: WrappedFunction = function(this: any): void {\n    // tslint:disable-next-line:strict-type-predicates\n    if (before && typeof before === 'function') {\n      before.apply(this, arguments);\n    }\n\n    const args = Array.prototype.slice.call(arguments);\n\n    // tslint:disable:no-unsafe-any\n    try {\n      const wrappedArguments = args.map((arg: any) => wrap(arg, options));\n\n      if (fn.handleEvent) {\n        // Attempt to invoke user-land function\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n        //       means the sentry.javascript SDK caught an error invoking your application code. This\n        //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n        return fn.handleEvent.apply(this, wrappedArguments);\n      }\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n      // tslint:enable:no-unsafe-any\n    } catch (ex) {\n      ignoreNextOnError();\n\n      withScope((scope: Scope) => {\n        scope.addEventProcessor((event: SentryEvent) => {\n          const processedEvent = { ...event };\n\n          if (options.mechanism) {\n            addExceptionTypeValue(processedEvent, undefined, undefined);\n            addExceptionMechanism(processedEvent, options.mechanism);\n          }\n\n          processedEvent.extra = {\n            ...processedEvent.extra,\n            arguments: normalize(args, 3),\n          };\n\n          return processedEvent;\n        });\n\n        captureException(ex);\n      });\n\n      throw ex;\n    }\n  };\n\n  // Accessing some objects may throw\n  // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch (_oO) {} // tslint:disable-line:no-empty\n\n  fn.prototype = fn.prototype || {};\n  sentryWrapped.prototype = fn.prototype;\n\n  Object.defineProperty(fn, '__sentry_wrapped__', {\n    enumerable: false,\n    value: sentryWrapped,\n  });\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  Object.defineProperties(sentryWrapped, {\n    __sentry__: {\n      enumerable: false,\n      value: true,\n    },\n    __sentry_original__: {\n      enumerable: false,\n      value: fn,\n    },\n  });\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name') as PropertyDescriptor;\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get(): string {\n          return fn.name;\n        },\n      });\n    }\n  } catch (_oO) {\n    /*no-empty*/\n  }\n\n  return sentryWrapped;\n}\n\nlet debounceTimer: number = 0;\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param eventName the event name (e.g. \"click\")\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nexport function breadcrumbEventHandler(eventName: string, debounce: boolean = false): (event: Event) => void {\n  return (event: Event) => {\n    // reset keypress timeout; e.g. triggering a 'click' after\n    // a 'keypress' will reset the keypress debounce so that a new\n    // set of keypresses can be recorded\n    keypressTimeout = undefined;\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors). Ignore if we've\n    // already captured the event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    lastCapturedEvent = event;\n\n    const captureBreadcrumb = () => {\n      let target;\n\n      // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n      try {\n        target = event.target ? htmlTreeAsString(event.target as Node) : htmlTreeAsString((event as unknown) as Node);\n      } catch (e) {\n        target = '<unknown>';\n      }\n\n      if (target.length === 0) {\n        return;\n      }\n\n      getCurrentHub().addBreadcrumb(\n        {\n          category: `ui.${eventName}`, // e.g. ui.click, ui.input\n          message: target,\n        },\n        {\n          event,\n          name: eventName,\n        },\n      );\n    };\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    if (debounce) {\n      debounceTimer = setTimeout(captureBreadcrumb);\n    } else {\n      captureBreadcrumb();\n    }\n  };\n}\n\n/**\n * Wraps addEventListener to capture keypress UI events\n * @returns wrapped keypress events handler\n * @hidden\n */\nexport function keypressEventHandler(): (event: Event) => void {\n  // TODO: if somehow user switches keypress target before\n  //       debounce timeout is triggered, we will only capture\n  //       a single breadcrumb from the FIRST target (acceptable?)\n  return (event: Event) => {\n    let target;\n\n    try {\n      target = event.target;\n    } catch (e) {\n      // just accessing event properties can throw an exception in some rare circumstances\n      // see: https://github.com/getsentry/raven-js/issues/838\n      return;\n    }\n\n    const tagName = target && (target as HTMLElement).tagName;\n\n    // only consider keypress events on actual input elements\n    // this will disregard keypresses targeting body (e.g. tabbing\n    // through elements, hotkeys, etc)\n    if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !(target as HTMLElement).isContentEditable)) {\n      return;\n    }\n\n    // record first keypress in a series, but ignore subsequent\n    // keypresses until debounce clears\n    if (!keypressTimeout) {\n      breadcrumbEventHandler('input')(event);\n    }\n    clearTimeout(keypressTimeout);\n\n    keypressTimeout = (setTimeout(() => {\n      keypressTimeout = undefined;\n    }, debounceDuration) as any) as number;\n  };\n}\n"]}